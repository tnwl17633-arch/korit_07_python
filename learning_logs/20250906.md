```python
class Student:
    def __init__(self, name, student_id):
        self.name: name
        self._student_id = student_id
        # 성적을 저장하기 위한 빅 딕셔너리 -> 과목명이 key, 점수가 value가 되겠네요.
        self._grades = {}        
```

1. 지난 복습 시간에 Java version의 setter / getter를 생성했습니다.
- 그런데 Java에는 access modifier 개념이 있었기 때문에 field를 private으로 선언했다면
setter / getter는 그냥 필수적이라고 봐도 됩니다.
- 문제는 python에는 access modifier라고 할만한 개념이 없기 때문에 모든 객체의 속성이 외부로 노출됩니다.
2. 이상을 이유로 python에서는 `_속성명`이라고 명시하게 되면, '내부적으로만 사용'하라고 권장되는 변수'라고 개발자들끼리 약속한 개념에 가까움.
3. name vs. _name
    - name
      - 공개적으로 접근 가능한 속성(Public Attribute)
      - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며, 다른 개발자가 이 변수를 직접 사용해도 괜찮음
    - `예시 : student.name = '김일'`과 같이 직접 접근하여 사용
    - _name
      - 내부용, 또는 비공[개 속성(Private Attribute)
      - python에는  Java와 같은 엄격한 접근 제어자가 없기 때문에 _를 붙여서 '외부에서 접근하지 마세요'와 같은 의미만 전달.]
      - 이런 변수는 일반적으로 `@property` 데코레이터를 사용한 getter와 setter를 경유하여 간접적으로 접근하는 것이 올바른 방법.
        
# JPA에서의 객체 생성 VS. python에서의 객체 생성
JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제합니다(springboot 에서도 적용됩니다). 그런데 python에서는 매개변수 생성자를 '권장'하는데, 이는 두 언어 간의 객체지향 패러다임과 데이터 관리 방식의 차이에 기인합니다.

1. Java(JPA)에서의 기본 생성자
    -JPA는 DB의 테이블과 (엔티티)클래스를 매핑하여 객체를 관리합니다(추후 수업할 거지만 제가 이미 이야기한대로라면 엔티티 클래스의 field가 DB에서의 컬럼명이 된다고 했었습니다). 이 과정에서 JPA가 지가 직접 매개변수를 알 수는 없기 떄문에 매개변수가 없는 기본 생성자를 먼저 호출하여 객체를 생성하고, DB에서의 컬럼 값들을 하나씩 필드에 집어넣어줍니다. 이상을 이유로 JPA는 데이터 관리의 일관성과 효율성을 위해 기본 생성자를 강제합니다.
```java
@Entity
@Data
public class Student {
    private String name;
    private int studentCode;
    
    // 기본 생성자가 강제됨
    public Student(){}
}

public class StudentMain {
    main {
        Student student1 = new Student();
        student1.setName('김일');
        student1.setStudentCode(2025001);
    }
}
```
이상의 코드라인처럼 일단 필드에 아무런 값이 없는 객체를 생성한 후에, DB상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해서 집어넣어주는 과정을 거치기 때문에 기본 생성자를 강제합니다.

2. python에서의 매개변수 생성자
    - 파이썬은 Java와 달리 동적 타이핑(Dynamic Typing) 언어라고 해서, 객체를 생성할 때 필수 속성들을 한 번에 초기화하는 것을 권장합니다.
   1. 객체 무결성 보장 : init 메서드(생성자겠네요)에서 모든 필수 매개변수를 받으면, 객체가 생성되는 시점에 이미 완전한 상태를 갖게 됩니다. -> 그  값이 적절한가는 추후에 따져야 하지만,
   2. 명확한 코드 작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지를 명확하게 알 수 있습니다. Java처럼 순서대로 하는 것도 아니고 keyword argumnet를 지원하기도 하니까요.

그리고 python과 db의 연동에 있어서 JPA처럼 값을 하나씩 집어넣기 보다는 ORM(Object-Relational Mapping) 라이브러리를 통해서 객체를 생성할 때 필요한 데이터를 직접 전달하는 방식으로 JPA와의 차이점이 있어 기본 생성자를 강제할 필요가 없습니다.

* 요약 : JPA는 DB와 연동하기 위한 기술적 제약으로 인해 기본 생성자를 명시해야하는 귀찮은 점이 있는데(매개변수 생성자를 하나라도 정의하는 순간 기본 생성자도 정의해야 하니까요. 그게 귀찮으면 롬복에서 @NoArgsConstructor를 쓰겠지), python은 객체의 완전성과 가독성을 중시하는 언어적 특성상 매개변수 생성자를 더 권장합니다.

ch08_coffee_machine

MENU = {
    '에스프레소': {
        '재료': {
          '물': 50,
          '커피': 18,
        },
        '가격': 1.5
    },
    '라뗴': {
       '재료': {
          '물': 200,
          '우유' : 150,
          '커피': 24,
       },
        '가격': 2.5,
    },
    '카푸치노': {
       '재료': {
         '물': 250,
         '우유' : 100,
         '커피': 24,
       },
      '가격' : 3.0,
    }
}

# 실행 예
# 카푸치노에는 우유가 100ml가 들어갑니다.
# 라고 콘솔에 출력할 수 있도록 카푸치노의 우유량을 추출하는 코드를 작성하시오.

# 에스프레소의 가격을 추출하시오.
print(MENU['에스프레소']['가격'])

# 라떼의 재료를 재료 이름만 출력하시오.
for key in MENU['라떼']['재료']:  # dictionary에서 반복문을 돌리게 되면 key가 나온다 그리고 그 key를 이용해서 value 조회 가능
    print(key, end=' ')

print()
print(' '.join((MENU['라떼']['재료'].keys())))

'''
37번 라인의 코드 작성 방식의 경우 key를 추출하여 dictionary의 value값에 접근할 수 있습니다. 그렇다면 연산이 가능하다는 의미도 됩니다.

40번 라인의 코드 작성 방식의 경우 value를 추출하는 것이 불가능하지만 한 줄에 간단하게 쓸 수 있다는 장점이 있습니다.(method를 아는 사람들에게만요).

에스프레소 / 라떼 / 카푸치노를 50잔씩 만든다고 가정했을 때 필요한 커피 / 우유 / 물의 양은 얼마인가?

'''
print()
coffee = 0
water = 0
milk = 0
for key in MENU:   # 결과값 : 에스프레소 / 라떼 / 카푸치노
    for key_key in MENU[Key]['재료']
    print(MENU[key]['재료'])([key_key])
    if key_key == '커피':
    for key in MENU[key]['재료']:
        print(MENU[key]['재료'][key_key])

print(coffee*50)
print(water*50)
print(milk*50)
'''
이상의 학습 과정에서 중요한 부분은 중첩적으로 이루어진 dictionary - JSON - 기타 collections들이 합쳐진 데이터에서 내가 필요한 부분을 어떻게 추출할 수 있을까 입니다.

일반적으로는 list의 경우 index를 이용하기 때문에 반복문 쓰고 치우면 그만인데 반해 dictionary는 반복문을 돌리면 key가 나오게 되고, 그 key를 또 이용해야지만 value가 추출됩니다.

그리고 그 value를 이용해서 연산을 하거나 로직을 작성해야 하죠.

근데 value가 또 dictionary거나 list거나 혹은 객체거나 한 경우에는 좀 복잡
이를 연습하기 위한 수업이었고 coffee_machine을 작성하면서는 중첩 dictionary를 활용
'''
```
```
2개 과목
1과목 - 서답형 / 50문항
2과목 - 코드 작성 / 4문항

코드라인 훑어보기(로직 위주)

1과목 - 데이터 분석 기초 기술 활용이지만 그냥 python
서답형이기 때문에 지난번과 동일한 방식
차이점은 python 저희 리포지토리의 내용을 최대한 담았다는 점.
그래서 로직 자체는 2과목에서 처리할 것이기 때문에 1과목은 되게되게되게 기본적인 것들

문제당 글자수가 30자 내외 그리고 답변은 사실 상 한 단어에 가까움

call1() - call4()를 구분하는 방식은 명확하게 파악해두도록
문자열에서 공백을 기준으로 맨 앞 글자만 대문자로 바꿔주는 메서드를 작성하시오.

1 - Python에서 한 줄 주석을 작성할 때 사용하는 기호를 작성하시오.

2과목 - 빅데이터 분석 결과 시각화(python 코드)
전체 4 문항 - 25/25/25/25

1 - 사용자로부터 전화번호를 입력받아, 특정 조건에 부합하는지 확인하고 전화번호의 중간 4자리를 출력하는 프로그램을 작성하시오. 전화번호는
하이픈(-)을 포함하여 총 13자리(예: 010-1234-5678)여야 한다.

지시사항:

1. 사용자로부터 전화번호를 입력받으시오.
2. 입력된 전화번호의 길이가 13자리가 아닐 경우, "유효하지 않은 전화번호 형식입니다." 라고 출력
3. 전화번호가 13자리일 경우, 전화번호의 중간 4자리(예:1234)를 추출하여 출력하시오.
4. 출력 시 f-string을 사용

실행 예:

전화번호를 입력하시오 >>> 010-9876-5432 전화번호의 중간 4자리는 9876입니다.
전화번호를 입력하시오 >>> 010-123-4567 유효하지 않은 전화번호 형식입니다.

-class 관련 문제
-collection 특징을 이용한 문제







